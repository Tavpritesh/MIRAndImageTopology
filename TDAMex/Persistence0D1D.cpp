#include <mex.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <math.h>#include <iostream>#include <algorithm>#include <iterator>#include <vector>#include <set>#include <assert.h>using namespace std;class HomologyClass {public:	int id;	int level;	double birthTime, deathTime;	bool died;	vector<void*> generators;		HomologyClass(int l, double bT) {		level = l;		birthTime = bT;		died = false;		id = -1;	}		void kill(double dT) {		deathTime = dT;		died = true;		PrintMex();	}		void addGenerator(void* generator) {		generators.push_back(generator);	}		int getID() {		return id;	}		void setID(int i) {		id = i;	}		void PrintMex() {		mexPrintf("Homology Class Level %i id %i: Born at %g, Died", level, id, birthTime);		if (died)			mexPrintf(" At %g\n", deathTime);		else			mexPrintf(" Never\n");	}};class TDAObject {public:	TDAObject(double d, int l, int i) {		dist = d;		level = l;		id = i;	}		TDAObject(int l, int i) {		level = l;		id = i;	}		virtual void getSortedNeighbors(vector<TDAObject*>* neighbors) {}	virtual void PrintMex() {		mexPrintf("TDAObject Parent Class\n");	}		int getLevel() {	return level;	}	int getID() {	return id;	}	void setID(int i) {		id = i;	}	double getDist() {	return dist;	}	void setDist(double d) {	dist = d;	}protected:	int level;	int id;	double dist;};//Compare two TDAObjects by their distance (ties broken by level to keep it a proper filtration)struct TDA_DistComparator {	bool operator()(TDAObject* o1, TDAObject* o2) const {		if (o1->getDist() < o2->getDist()) {			return true;		}		else if (o1->getDist() == o2->getDist()) {			//Make sure to add the faces of a simplex before adding the simplex			return o1->getLevel() < o2->getLevel();		}		return false;	}};//Compare two TDAObjects by ID (used to help keep the columns of the sparse matrix in order)struct TDA_IDComparator {	bool operator()(TDAObject* o1, TDAObject* o2) const {		return o1->getID() < o2->getID();	}};struct MemAddressComparator {	bool operator()(const void* o1, const void* o2) const {		return o1 < o2;	}};class TDAVertex: public TDAObject {public:	TDAVertex(double d, int i):TDAObject(d, 0, i) {		homologyClass = NULL;	}	HomologyClass* getHomologyClass() { return homologyClass; }	void setHomologyClass(HomologyClass* c) { homologyClass = c; }	virtual void getSortedNeighbors(vector<TDAObject*>* neighbors) {}	virtual void PrintMex() {		mexPrintf("TDAVertex(%i): id = %i, dist = %g\n", level, id, dist);	}private:	HomologyClass* homologyClass;};class TDAEdge: public TDAObject {public:	set<HomologyClass*, MemAddressComparator> homologyClasses;	TDAEdge(double d, int i, TDAVertex* v1, TDAVertex* v2):TDAObject(d, 1, i) {		this->v1 = v1;		this->v2 = v2;	}	virtual void getSortedNeighbors(vector<TDAObject*>* neighbors) {		neighbors->clear();		neighbors->push_back(v1);		neighbors->push_back(v2);		sort(neighbors->begin(), neighbors->end(), TDA_IDComparator());	}	virtual void PrintMex() {		mexPrintf("TDAEdge(%i): id = %i, dist = %g, v1-id = %i, v2-id = %i\n", level, id, dist, v1->getID(), v2->getID());	}private:	TDAVertex *v1, *v2;};class TDAFace: public TDAObject {public:	TDAEdge *e1, *e2, *e3;	TDAFace(int i, TDAEdge* e1, TDAEdge* e2, TDAEdge* e3):TDAObject(2, i) {		this->e1 = e1;		this->e2 = e2;		this->e3 = e3;		//A face gets added as soon as the last of its three edges has been added		this->setDist( max( max(e1->getDist(), e2->getDist()), e3->getDist()) );	}	virtual void getSortedNeighbors(vector<TDAObject*>* neighbors) {		neighbors->clear();		neighbors->push_back(e1);		neighbors->push_back(e2);		neighbors->push_back(e3);		sort(neighbors->begin(), neighbors->end(), TDA_IDComparator());	}	virtual void PrintMex() {		mexPrintf("TDAFace(%i): id = %i, dist = %g, e1-id = %i, e2-id = %i, e3-id = %i\n", level, id, dist, e1->getID(), e2->getID(), e3->getID());	}};//Do linear time addition of two sorted columns in the sparse matrix//This method assumes that col1 and col2 are in sorted order by TDAObject.idvoid addColToColMod2(vector<TDAObject*>& col1, vector<TDAObject*>& col2) {	int i1 = 0, i2 = 0;	vector<TDAObject*> out;//	mexPrintf("\n\nAdding Columns Mod2\n");//	for (size_t i = 0; i < col1.size(); i++) {//		mexPrintf("%i ", col1[i]->getID());//	}//	mexPrintf("\n");//	for (size_t i = 0; i < col2.size(); i++) {//		mexPrintf("%i ", col2[i]->getID());//	}//	mexPrintf("\n");	while (i1 < (int)col1.size() && i2 < (int)col2.size()) {		int id1 = col1[i1]->getID();		int id2 = col2[i2]->getID();		if (id1 == id2) {			i1++;			i2++;			//Do nothing; they cancel out mod2 if they are the same		}		else if (id1 < id2) {			//Add the element from col1 first and move down one element on col1			out.push_back(col1[i1]);			i1++;		}		else if (id2 < id1) {			//Add the element from col2 first and move down one element on col2			out.push_back(col2[i2]);			i2++;		}		if (i1 == (int)col1.size()) {			//Add the rest of the elements from column 2 if we're through column 1			while (i2 < (int)col2.size()) {				out.push_back(col2[i2]);				i2++;			}		}		if (i2 == (int)col2.size()) {			//Add the rest of the elements from column 1 if we're through column 2			while (i1 < (int)col1.size()) {				out.push_back(col1[i1]);				i1++;			}		}	}	//Overwrite col2 with the result	col2.clear();	col2.insert(col2.begin(), out.begin(), out.end());//	for (size_t i = 0; i < col2.size(); i++) {//		mexPrintf("%i ", col2[i]->getID());//	}//	mexPrintf("\n\n");}//Add the column "col" to every subsequent column in B that contains the low //element of col in the matrix B (and do that in parallel with R)//This method assumes that col1 and col2 are in sorted order by TDAObject.idvoid addLowElementToOthers(vector<TDAObject*>* B, vector<TDAObject*>* R, int col, int N) {	assert(col < N);	assert(B[col].size() > 0);	TDAObject* low = (B[col])[B[col].size()-1];//The low element is the last element in sorted order	for (int j = col+1; j < N; j++) {		//Check to see if this column has the low element		for (int k = 0; k < B[j].size(); k++) {			if ((B[j])[k] == low) {				//This column does contain the low element so add B[col] to it				addColToColMod2(B[col], B[j]);				addColToColMod2(R[col], R[j]);				break;			}		}	}}void findCommonHomologySetsForFace(TDAFace* face, vector<HomologyClass*>& intersection) {	set_intersection(face->e1->homologyClasses.begin(), face->e1->homologyClasses.end(), 		face->e2->homologyClasses.begin(), face->e2->homologyClasses.end(), 		std::back_inserter(intersection), MemAddressComparator());	set<HomologyClass*, MemAddressComparator> intersectionSet;	for (int k = 0; k < (int)intersection.size(); k++) {		intersectionSet.insert(intersection[k]);	}	intersection.clear();	set_intersection(face->e3->homologyClasses.begin(), face->e3->homologyClasses.end(), 		intersectionSet.begin(), intersectionSet.end(), 		std::back_inserter(intersection), MemAddressComparator());}void findCommonHomologySetsForEdges(TDAEdge* e1, TDAEdge* e2, vector<HomologyClass*>& intersection) {	set_intersection(e1->homologyClasses.begin(), e1->homologyClasses.end(), 		e2->homologyClasses.begin(), e2->homologyClasses.end(), 		std::back_inserter(intersection), MemAddressComparator());}void doReduction(vector<TDAObject*>& tdaObjs, vector<HomologyClass*>& homologyClasses) {	//Put the filtration in order and reset the IDs based on that order	sort(tdaObjs.begin(), tdaObjs.end(), TDA_DistComparator());	int N = (int)tdaObjs.size();	for (int i = 0; i < N; i++) {		tdaObjs[i]->setID(i);		tdaObjs[i]->PrintMex();	}			//Initialize the sparse matrix structures in the co-reduction	//Keep the vectors at each column in order by ID for efficient merging	vector<TDAObject*>* B = new vector<TDAObject*>[tdaObjs.size()];//Boundary matrix that's reduced	vector<TDAObject*>* R = new vector<TDAObject*>[tdaObjs.size()];//Identity matrix that's reduced in parallel	for (int i = 0; i < N; i++) {		R[i].push_back(tdaObjs[i]);		tdaObjs[i]->getSortedNeighbors(&B[i]);	}		//Now add each object in the order of the filtration	for (int i = 0; i < N; i++) {		double dist = tdaObjs[i]->getDist();				if (tdaObjs[i]->getLevel() == 0) {//A vertex is added			//When a vertex is added a 0D homology class is automatically 			//created with that vertex as a generator. Homology class is born at "dist"			assert(B[i].size() == 0);			HomologyClass* c = new HomologyClass(0, dist);			c->addGenerator(tdaObjs[i]);			((TDAVertex*)tdaObjs[i])->setHomologyClass(c);			homologyClasses.push_back(c);		}		else if (tdaObjs[i]->getLevel() == 1) {//An edge is added			TDAEdge* e = (TDAEdge*)tdaObjs[i];			if (B[i].size() == 0) {				//If it's a row of all zeros, add a 1D homology class born at "dist"				//with the generators as the edges found in the coreduced matrix				HomologyClass* c = new HomologyClass(1, dist);				for (int k = 0; k < (int)R[i].size(); k++) {					assert(R[i][k]->getLevel() == 1);					TDAEdge* e = (TDAEdge*)R[i][k];					c->addGenerator(e);					//Add a pointer to this homology class from every element in the generator					e->homologyClasses.insert(c);				}				homologyClasses.push_back(c);			}			else {				//Otherwise if a low element exists, kill the class associated with 				//that element, and make the class of the low element the class 				//of the high element				assert(B[i].size() == 2);				assert(B[i][0]->getLevel() == 0);				assert(B[i][1]->getLevel() == 0);				TDAVertex* v1 = (TDAVertex*)B[i][0];				TDAVertex* v2 = (TDAVertex*)B[i][1];				HomologyClass* c1 = (HomologyClass*)v1->getHomologyClass();				HomologyClass* c2 = (HomologyClass*)v2->getHomologyClass();				assert(c1 != NULL);				assert(c2 != NULL);				c2->kill(dist);//This class gets killed at "dist"				v2->setHomologyClass(c1);				//Also add this column to all other columns that contain the low element				addLowElementToOthers(B, R, i, N); 			}		}		else if (tdaObjs[i]->getLevel() == 2) {//A triangle face is added			//If a low element exists, find the homology class in common with 			//all 3 edges and kill it (there must be at least one because the rank of			//boundary 2 is increasing by 1)			//NOTE: Nothing is done if the column is all zeros, because we're not keeping track			//of 2D homology classes (yet)			if (B[i].size() > 0) {				TDAFace* face = (TDAFace*)tdaObjs[i];				vector<HomologyClass*> classesInCommon;				findCommonHomologySetsForFace(face, classesInCommon);				if (classesInCommon.size() == 0) {					cerr << "Error: No common homology class found between 3 edges when a triangle face was added\n";					continue;				}				if (classesInCommon.size() > 1) {					cerr << "Warning: More than one homology class found in common between 3 edges when a triangle face was added\n";					continue;				}				classesInCommon[0]->kill(dist);//Kill the common homology class				//and remove it from all of the edges				face->e1->homologyClasses.erase(classesInCommon[0]);				face->e2->homologyClasses.erase(classesInCommon[0]);				face->e3->homologyClasses.erase(classesInCommon[0]);								//Now find any homology classes that the lower two edges (two edges added first)				//have in common, delete these classes from the original two edges and move them				//down to the third one				TDAEdge* edges[3] = {face->e1, face->e2, face->e3};				//Figure out which two edges were added first				sort(edges, edges+2, TDA_IDComparator());				classesInCommon.clear();				findCommonHomologySetsForEdges(edges[0], edges[1], classesInCommon);				cout << classesInCommon.size() << " homology classes moved down across a filled in triangle\n";				for (int k = 0; k < classesInCommon.size(); i++) {					//Delete the homology classes from the first two edges					edges[0]->homologyClasses.erase(classesInCommon[k]);					edges[1]->homologyClasses.erase(classesInCommon[k]);					//Move the classes across the triangle to the most recently added edge					edges[2]->homologyClasses.insert(classesInCommon[k]);				}				//Also add this column to all other columns that contain the low element				addLowElementToOthers(B, R, i, N);			}		}		else {			cerr << "TDA objects are not supported at level " << tdaObjs[i]->getLevel() << endl;		}	}//End of filtration loop}//Helper function for finding faces between sets of 3 points//Returns the edge in tdaObjs between vertex i and vertex jTDAEdge* getEdge(vector<TDAObject*>& tdaObjs, int i, int j, int N) {	if (j <= i) { //Assume we're looking at the upper triangular part of the distance matrix		cerr << "Error: Improper vertex indices specified for edge\n";		return NULL;	}	return (TDAEdge*)tdaObjs[N + i*N - i*(i+1)/2 + j - (i+1)];}void mexFunction(int nOutArray, mxArray *OutArray[], int nInArray, const mxArray *InArray[]) {  	double* D;		if (nInArray < 1) {		mexErrMsgTxt("Distance Matrix Input Required");		return;	}		const mwSize *dims;	size_t rowsD, colsD;	int ndim = mxGetNumberOfDimensions(InArray[0]);	if (ndim != 2) {		mexErrMsgTxt("Expecting 2D matrix as first input");		return;	}	dims = mxGetDimensions(InArray[0]);	rowsD = dims[0];	colsD = dims[1];	if (rowsD != colsD) {		mexErrMsgTxt("Number of rows not equal to number of columns in distance matrix");		return;	}	D = (double*)mxGetPr(InArray[0]);	size_t N = rowsD;		vector<TDAObject*> tdaObjs;	vector<HomologyClass*> homologyClasses;	//NOTE: I only look at the upper triangular portion of the matrix because	//it is assumed to be symmetric		//Add the TDA vertices first	for (size_t i = 0; i < N; i++) {		TDAVertex* v = new TDAVertex(D[i*N+i], -1);		tdaObjs.push_back(v);	}	//Now add the edges	for (size_t i = 0; i < N; i++) {		for (size_t j = i+1; j < N; j++) {			double dist = D[j*N+i];			TDAVertex* v1 = (TDAVertex*)tdaObjs[i];			TDAVertex* v2 = (TDAVertex*)tdaObjs[j];			TDAEdge* e = new TDAEdge(dist, -1, v1, v2);			tdaObjs.push_back(e);		}	}	//Now add the faces (Look between all sets of 3 points)	for (size_t i = 0; i < N; i++) {		for (size_t j = i+1; j < N; j++) {			for (size_t k = j+1; k < N; k++) {				//Edge i-j				TDAEdge* e1 = getEdge(tdaObjs, i, j, N);				//Edge j-k				TDAEdge* e2 = getEdge(tdaObjs, j, k, N);				//Edge i-k				TDAEdge* e3 = getEdge(tdaObjs, i, k, N);				TDAFace* f = new TDAFace(-1, e1, e2, e3);				tdaObjs.push_back(f);			}		}	}		doReduction(tdaObjs, homologyClasses);	vector<HomologyClass*> classes0D;	vector<HomologyClass*> classes1D;	for (size_t i = 0; i < homologyClasses.size(); i++) {		HomologyClass* c = homologyClasses[i];		c->setID(i);		if (c->birthTime != c->deathTime || !c->died) { //Prune away all homology classes with birth time = death time			if (c->level == 0) {				classes0D.push_back(c);			}			else if (c->level == 1) {				classes1D.push_back(c);			}			else {				cerr << "Warning: Unsupported homology class at level " << c->level << endl;			}		}		c->PrintMex();	}		mwSize outdims[2];	//Output 0D homology classes	outdims[0] = classes0D.size();	outdims[1] = 2;	OutArray[0] = mxCreateNumericArray(2, outdims, mxDOUBLE_CLASS, mxREAL);	double *I = (double*)mxGetPr(OutArray[0]);	N = classes0D.size();	for (size_t i = 0; i < N; i++) {		I[i] = classes0D[i]->birthTime;		if (classes0D[i]->died) {			I[N+i] = classes0D[i]->deathTime;		}		else {			I[N+i] = -1;//TODO: Better choice than -1 for death time for classes that never die		}	}		//Output 1D homology classes	outdims[0] = classes1D.size();	outdims[1] = 2;	OutArray[1] = mxCreateNumericArray(2, outdims, mxDOUBLE_CLASS, mxREAL);	double *J = (double*)mxGetPr(OutArray[1]);	N = classes1D.size();	for (size_t i = 0; i < N; i++) {		J[i] = classes1D[i]->birthTime;		if (classes1D[i]->died) {			J[N+i] = classes1D[i]->deathTime;		}		else {			J[N+i] = -1;//TODO: Better choice than -1 for death time for classes that never die		}	}		//TODO: Save generators in cell array		//Clear all memory from homology classes and TDA Objects	for (size_t i = 0; i < homologyClasses.size(); i++) {		delete homologyClasses[i];	}	for (size_t i = 0; i < tdaObjs.size(); i++) {		delete tdaObjs[i];	}}