#include <mex.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <math.h>#include <iostream>#include <algorithm>#include <iterator>#include <vector>#include <set>#include <assert.h>using namespace std;class HomologyClass {public:	HomologyClass(int l, double bT) {		level = l;		birthTime = bT;	}		void kill(double dT) {		deathTime = dT;	}		void addGenerator(void* generator) {		generators.push_back(generator);	}private:	int level;	double birthTime, deathTime;	vector<void*> generators;};class TDAObject {public:	TDAObject(double d, int l, int i) {		dist = d;		level = l;		id = i;	}		TDAObject(int l, int i) {		level = l;		id = i;	}		bool operator<(TDAObject other) {		if (dist < other.dist) {			return true;		}		else if (dist == other.dist) {			//Make sure to add the faces of a simplex before adding the simplex			return level < other.level;		}		return false;	}		virtual void getSortedNeighbors(vector<TDAObject*>* neighbors) {}		int getLevel() {	return level;	}	int getID() {	return id;	}	void setID(int i) {		id = i;	}	double getDist() {	return dist;	}	void setDist(double d) {	dist = d;	}protected:	int level;	int id;	double dist;};//Compare two TDAObjects by ID (used to help keep the columns of the sparse matrix in order)struct IDComparator {	bool operator()(TDAObject* o1, TDAObject* o2) const {		return o1->getID() < o2->getID();	}};struct MemAddressComparator {	bool operator()(const void* o1, const void* o2) const {		return o1 < o2;	}};class TDAVertex: public TDAObject {public:	TDAVertex(double d, int i):TDAObject(d, 0, i) {}	virtual void getSortedNeighbors(vector<TDAObject*>* neighbors) {}	HomologyClass* getHomologyClass() { return homologyClass; }	void setHomologyClass(HomologyClass* c) { homologyClass = c; }private:	HomologyClass* homologyClass;};class TDAEdge: public TDAObject {public:	set<HomologyClass*, MemAddressComparator> homologyClasses;	TDAEdge(double d, int i, TDAVertex* v1, TDAVertex* v2):TDAObject(d, 1, i) {		this->v1 = v1;		this->v2 = v2;	}	virtual void getSortedNeighbors(vector<TDAObject*>* neighbors) {		neighbors->clear();		neighbors->push_back(v1);		neighbors->push_back(v2);		sort(neighbors->begin(), neighbors->end(), IDComparator());	}private:	TDAVertex *v1, *v2;};class TDAFace: public TDAObject {public:	TDAEdge *e1, *e2, *e3;	TDAFace(int i, TDAEdge* e1, TDAEdge* e2, TDAEdge* e3):TDAObject(2, i) {		this->e1 = e1;		this->e2 = e2;		this->e3 = e3;		//A face gets added as soon as the last of its three edges has been added		this->setDist( max( max(e1->getDist(), e2->getDist()), e3->getDist()) );	}	virtual void getSortedNeighbors(vector<TDAObject*>* neighbors) {		neighbors->clear();		neighbors->push_back(e1);		neighbors->push_back(e2);		neighbors->push_back(e3);		sort(neighbors->begin(), neighbors->end(), IDComparator());	}};//Do linear time addition of two sorted columns in the sparse matrix//This method assumes that col1 and col2 are in sorted order by TDAObject.idvoid addColToColMod2(vector<TDAObject*>& col1, vector<TDAObject*>& col2) {	int i1 = 0, i2 = 0;	vector<TDAObject*> out;	while (i1 < (int)col1.size() && i2 < (int)col2.size()) {		int id1 = col1[i1]->getID();		int id2 = col2[i2]->getID();		if (id1 == id2) {			//Do nothing; they cancel out mod2 if they are the same		}		else if (id1 < id2) {			//Add the element from col1 first and move down one element on col1			out.push_back(col1[i1]);			i1++;		}		else if (id2 < id1) {			//Add the element from col2 first and move down one element on col2			out.push_back(col2[i2]);			i2++;		}		if (i1 == (int)col1.size()) {			//Add the rest of the elements from column 2 if we're through column 1			while (i2 < (int)col2.size()) {				out.push_back(col2[i2]);				i2++;			}		}		if (i2 == (int)col2.size()) {			//Add the rest of the elements from column 1 if we're through column 2			while (i1 < (int)col1.size()) {				out.push_back(col1[i1]);				i1++;			}		}	}	//Overwrite col2 with the result	col2.clear();	col2.insert(col2.begin(), out.begin(), out.end());}//Add the column "col" to every subsequent column in B that contains the low //element of col in the matrix B (and do that in parallel with R)//This method assumes that col1 and col2 are in sorted order by TDAObject.idvoid addLowElementToOthers(vector<TDAObject*>* B, vector<TDAObject*>* R, int col, int N) {	assert(col < N);	assert(B[col].size() > 0);	TDAObject* low = (B[col])[B[col].size()-1];//The low element is the last element in sorted order	for (int j = col+1; j < N; j++) {		//Check to see if this column has the low element		for (int k = 0; k < B[j].size(); k++) {			if ((B[j])[k] == low) {				//This column does contain the low element so add B[col] to it				addColToColMod2(B[col], B[j]);				addColToColMod2(R[col], R[j]);				break;			}		}	}}void findCommonHomologySetsForFace(TDAFace* face, vector<HomologyClass*>& intersection) {	set_intersection(face->e1->homologyClasses.begin(), face->e1->homologyClasses.end(), 		face->e2->homologyClasses.begin(), face->e2->homologyClasses.end(), 		std::back_inserter(intersection), MemAddressComparator());	set<HomologyClass*, MemAddressComparator> intersectionSet;	for (int k = 0; k < (int)intersection.size(); k++) {		intersectionSet.insert(intersection[k]);	}	intersection.clear();	set_intersection(face->e3->homologyClasses.begin(), face->e3->homologyClasses.end(), 		intersectionSet.begin(), intersectionSet.end(), 		std::back_inserter(intersection), MemAddressComparator());}void findCommonHomologySetsForEdges(TDAEdge* e1, TDAEdge* e2, vector<HomologyClass*>& intersection) {	set_intersection(e1->homologyClasses.begin(), e1->homologyClasses.end(), 		e2->homologyClasses.begin(), e2->homologyClasses.end(), 		std::back_inserter(intersection), MemAddressComparator());}/*Before returning the final answer, prune away all homology classes with birth time = death time*/void doReduction(vector<TDAObject*>& tdaObjs, vector<HomologyClass*>& homologyClasses) {	//Put the filtration in order and reset the IDs based on that order	sort(tdaObjs.begin(), tdaObjs.end());	int N = (int)tdaObjs.size();	for (int i = 0; i < N; i++) {		tdaObjs[i]->setID(i);	}		//Initialize the sparse matrix structures in the co-reduction	//Keep the vectors at each column in order by ID for efficient merging	vector<TDAObject*>* B = new vector<TDAObject*>[tdaObjs.size()];//Boundary matrix that's reduced	vector<TDAObject*>* R = new vector<TDAObject*>[tdaObjs.size()];//Identity matrix that's reduced in parallel	for (int i = 0; i < N; i++) {		R[i].push_back(tdaObjs[i]);		tdaObjs[i]->getSortedNeighbors(&B[i]);	}		//Now add each object in the order of the filtration	for (int i = 0; i < N; i++) {		double dist = tdaObjs[i]->getDist();				if (tdaObjs[i]->getLevel() == 0) {//A vertex is added			//When a vertex is added a 0D homology class is automatically 			//created with that vertex as a generator. Homology class is born at "dist"			assert(B[i].size() == 0);			HomologyClass* c = new HomologyClass(0, dist);			c->addGenerator(tdaObjs[i]);			homologyClasses.push_back(c);		}		else if (tdaObjs[i]->getLevel() == 1) {//An edge is added			TDAEdge* e = (TDAEdge*)tdaObjs[i];			if (B[i].size() == 0) {				//If it's a row of all zeros, add a 1D homology class born at "dist"				//with the generators as the edges found in the coreduced matrix				HomologyClass* c = new HomologyClass(1, dist);				for (int k = 0; k < (int)R[i].size(); i++) {					TDAEdge* e = (TDAEdge*)R[i][k];					c->addGenerator(e);					//Add a pointer to this homology class from every element in the generator					e->homologyClasses.insert(c);				}				homologyClasses.push_back(c);			}			else {				//Otherwise if a low element exists, kill the class associated with 				//that element, and make the class of the low element the class 				//of the high element				assert(B[i].size() == 2);				assert(B[i][0]->getLevel() == 0);				assert(B[i][1]->getLevel() == 0);				TDAVertex* v1 = (TDAVertex*)B[i][0];				TDAVertex* v2 = (TDAVertex*)B[i][1];				v2->getHomologyClass()->kill(dist);//This class gets killed at "dist"				v2->setHomologyClass(v1->getHomologyClass());				//Also add this column to all other columns that contain the low element				addLowElementToOthers(B, R, i, N); 			}		}		else if (tdaObjs[i]->getLevel() == 2) {//A triangle face is added			//If a low element exists, find the homology class in common with 			//all 3 edges and kill it (there must be at least one because the rank of			//boundary 2 is increasing by 1)			//NOTE: Nothing is done if the column is all zeros, because we're not keeping track			//of 2D homology classes (yet)			if (B[i].size() > 0) {				TDAFace* face = (TDAFace*)tdaObjs[i];				vector<HomologyClass*> intersection;				findCommonHomologySetsForFace(face, intersection);				if (intersection.size() == 0) {					cerr << "Error: No common homology class found between 3 edges when a triangle face was added\n";					continue;				}				if (intersection.size() > 1) {					cerr << "Warning: More than one homology class found in common between 3 edges when a triangle face was added\n";					continue;				}				intersection[0]->kill(dist);//Kill the common homology class				//and remove it from all of the edges				face->e1->homologyClasses.erase(intersection[0]);				face->e2->homologyClasses.erase(intersection[0]);				face->e3->homologyClasses.erase(intersection[0]);								//Now find any homology classes that the lower two edges (two edges added first)				//have in common, delete these classes from the original two edges and move them				//down to the third one				TDAEdge* edges[3] = {face->e1, face->e2, face->e3};				//Figure out which two edges were added first				sort(edges, edges+2, IDComparator());				intersection.clear();				findCommonHomologySetsForEdges(edges[0], edges[1], intersection);				cout << intersection.size() << " homology classes moved down across a filled in triangle\n";				for (int k = 0; k < intersection.size(); i++) {					//Delete the homology classes from the first two edges					edges[0]->homologyClasses.erase(intersection[k]);					edges[1]->homologyClasses.erase(intersection[k]);					//Move the classes across the triangle to the most recently added edge					edges[2]->homologyClasses.insert(intersection[k]);				}				//Also add this column to all other columns that contain the low element				addLowElementToOthers(B, R, i, N);			}		}		else {			cerr << "TDA objects are not supported at level " << tdaObjs[i]->getLevel() << endl;		}	}//End of filtration loop}void mexFunction(int nOutArray, mxArray *OutArray[], int nInArray, const mxArray *InArray[]) {  	/*float *A;		//Check if there is an Input matrix	if (nInArray < 1) {		mexErrMsgTxt("1 input required.");		return;	}		//Set up A matrix	ndim =  mxGetNumberOfDimensions(InArray[0]);	if (ndim != 2) {		mexErrMsgTxt("Expecting 2D matrix as first input");		return;	}	dims = mxGetDimensions(InArray[0]);    	rowsA  = dims[0];	colsA  = dims[1];	if (rowsA != colsA) {		mexErrMsgTxt("Number of rows not equal to number of columns");		return;	}	N = rowsA;	//mexPrintf("Matrix A is %i x %i\n", rows, cols);	A = (float*)mxGetPr(InArray[0]);*/		/*mwSize outdims[2];	outdims[0] = N;	outdims[1] = N;	OutArray[0] = mxCreateNumericArray(2, outdims, mxSINGLE_CLASS, mxREAL);	float *AInv = (float*)mxGetPr(OutArray[0]);*/}